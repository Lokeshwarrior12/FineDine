{"version":3,"names":["Object","defineProperty","exports","value","processUniforms","isShader","obj","__typename__","isVector","x","undefined","y","processValue","values","push","Array","isArray","forEach","v","Float32Array","source","uniforms","builder","result","uniformsCount","getUniformCount","i","name","getUniformName","Error","uniformValue","setUniform"],"sources":["Shader.ts"],"sourcesContent":["\"worklet\";\n\nimport type { SkJSIInstance } from \"../JsiInstance\";\nimport type { Vector } from \"../Point\";\nimport type { SkRuntimeEffect, SkRuntimeShaderBuilder } from \"../RuntimeEffect\";\n\nexport const isShader = (obj: SkJSIInstance<string> | null): obj is SkShader =>\n  obj !== null && obj.__typename__ === \"Shader\";\n\nexport type SkShader = SkJSIInstance<\"Shader\">;\n\nexport type Uniform =\n  | number\n  | Vector\n  | Float32Array\n  | readonly Uniform[]\n  | Uniform[];\n\nexport interface Uniforms {\n  [name: string]: Uniform;\n}\n\nconst isVector = (obj: unknown): obj is Vector => {\n  // We have an issue to check property existence on JSI backed instances\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (obj as any).x !== undefined && (obj as any).y !== undefined;\n};\n\nfunction processValue(values: number[], value: Uniform) {\n  if (typeof value === \"number\") {\n    values.push(value);\n  } else if (Array.isArray(value)) {\n    value.forEach((v) => processValue(values, v));\n  } else if (isVector(value)) {\n    values.push(value.x, value.y);\n  } else if (value instanceof Float32Array) {\n    values.push(...value);\n  }\n}\n\nexport const processUniforms = (\n  source: SkRuntimeEffect,\n  uniforms: Uniforms,\n  builder?: SkRuntimeShaderBuilder\n) => {\n  const result: number[] = [];\n  const uniformsCount = source.getUniformCount();\n  for (let i = 0; i < uniformsCount; i++) {\n    const name = source.getUniformName(i);\n    const value = uniforms[name];\n    if (value === undefined) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `The runtime effect has the uniform value \"${name}\" declared, but it is missing from the uniforms property of the Runtime effect.`\n      );\n    }\n    if (builder === undefined) {\n      processValue(result, value);\n    } else {\n      const uniformValue: number[] = [];\n      processValue(uniformValue, value);\n      builder.setUniform(name, uniformValue);\n      result.push(...uniformValue);\n    }\n  }\n  return result;\n};\n"],"mappings":";AAAA,SAAS;;AAACA,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,KAAA;AAAA;AAAAD,OAAA,CAAAE,eAAA,GAAAF,OAAA,CAAAG,QAAA;AAMH,MAAMA,QAAQ,GAAIC,GAAiC,IACxDA,GAAG,KAAK,IAAI,IAAIA,GAAG,CAACC,YAAY,KAAK,QAAQ;AAACL,OAAA,CAAAG,QAAA,GAAAA,QAAA;AAehD,MAAMG,QAAQ,GAAIF,GAAY,IAAoB;EAChD;EACA;EACA,OAAQA,GAAG,CAASG,CAAC,KAAKC,SAAS,IAAKJ,GAAG,CAASK,CAAC,KAAKD,SAAS;AACrE,CAAC;AAED,SAASE,YAAYA,CAACC,MAAgB,EAAEV,KAAc,EAAE;EACtD,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7BU,MAAM,CAACC,IAAI,CAACX,KAAK,CAAC;EACpB,CAAC,MAAM,IAAIY,KAAK,CAACC,OAAO,CAACb,KAAK,CAAC,EAAE;IAC/BA,KAAK,CAACc,OAAO,CAAEC,CAAC,IAAKN,YAAY,CAACC,MAAM,EAAEK,CAAC,CAAC,CAAC;EAC/C,CAAC,MAAM,IAAIV,QAAQ,CAACL,KAAK,CAAC,EAAE;IAC1BU,MAAM,CAACC,IAAI,CAACX,KAAK,CAACM,CAAC,EAAEN,KAAK,CAACQ,CAAC,CAAC;EAC/B,CAAC,MAAM,IAAIR,KAAK,YAAYgB,YAAY,EAAE;IACxCN,MAAM,CAACC,IAAI,CAAC,GAAGX,KAAK,CAAC;EACvB;AACF;AAEO,MAAMC,eAAe,GAAGA,CAC7BgB,MAAuB,EACvBC,QAAkB,EAClBC,OAAgC,KAC7B;EACH,MAAMC,MAAgB,GAAG,EAAE;EAC3B,MAAMC,aAAa,GAAGJ,MAAM,CAACK,eAAe,CAAC,CAAC;EAC9C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,aAAa,EAAEE,CAAC,EAAE,EAAE;IACtC,MAAMC,IAAI,GAAGP,MAAM,CAACQ,cAAc,CAACF,CAAC,CAAC;IACrC,MAAMvB,KAAK,GAAGkB,QAAQ,CAACM,IAAI,CAAC;IAC5B,IAAIxB,KAAK,KAAKO,SAAS,EAAE;MACvB,MAAM,IAAImB,KAAK;MACb;MACA,6CAA6CF,IAAI,iFACnD,CAAC;IACH;IACA,IAAIL,OAAO,KAAKZ,SAAS,EAAE;MACzBE,YAAY,CAACW,MAAM,EAAEpB,KAAK,CAAC;IAC7B,CAAC,MAAM;MACL,MAAM2B,YAAsB,GAAG,EAAE;MACjClB,YAAY,CAACkB,YAAY,EAAE3B,KAAK,CAAC;MACjCmB,OAAO,CAACS,UAAU,CAACJ,IAAI,EAAEG,YAAY,CAAC;MACtCP,MAAM,CAACT,IAAI,CAAC,GAAGgB,YAAY,CAAC;IAC9B;EACF;EACA,OAAOP,MAAM;AACf,CAAC;AAACrB,OAAA,CAAAE,eAAA,GAAAA,eAAA","ignoreList":[]}