"use strict";
"worklet";

/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.draw = draw;
var _types = require("../../dom/types");
var _types2 = require("../../skia/types");
var _nodes = require("../../dom/nodes");
var _drawings = require("./drawings");
var _colorFilters = require("./colorFilters");
var _imageFilters = require("./imageFilters");
var _utils = require("./utils");
var _shaders = require("./shaders");
var _paint = require("./paint");
var _pathEffects = require("./pathEffects");
function composeColorFilters(ctx, cf, processChildren) {
  const {
    Skia
  } = ctx;
  ctx.save();
  processChildren();
  const cf1 = ctx.colorFilters.popAllAsOne();
  ctx.restore();
  ctx.colorFilters.push(cf1 ? Skia.ColorFilter.MakeCompose(cf, cf1) : cf);
}
function composePathEffects(ctx, pe, processChildren) {
  const {
    Skia
  } = ctx;
  ctx.save();
  processChildren();
  const pe1 = ctx.pathEffects.popAllAsOne();
  ctx.restore();
  ctx.pathEffects.push(pe1 ? Skia.PathEffect.MakeCompose(pe, pe1) : pe);
}
function composeImageFilters(ctx, imgf1, processChildren) {
  const {
    Skia
  } = ctx;
  ctx.save();
  processChildren();
  let imgf2 = ctx.imageFilters.popAllAsOne();
  const cf = ctx.colorFilters.popAllAsOne();
  ctx.restore();
  if (cf) {
    var _imgf;
    imgf2 = Skia.ImageFilter.MakeCompose((_imgf = imgf2) !== null && _imgf !== void 0 ? _imgf : null, Skia.ImageFilter.MakeColorFilter(cf, null));
  }
  const imgf = imgf2 ? Skia.ImageFilter.MakeCompose(imgf1, imgf2) : imgf1;
  ctx.imageFilters.push(imgf);
}
function processDeclarations(ctx, node) {
  const processChildren = () => node.children.forEach(child => processDeclarations(ctx, child));
  const {
    type
  } = node;
  const props = (0, _utils.materialize)(node.props);
  switch (type) {
    // Mask Filter
    case _types.NodeType.BlurMaskFilter:
      {
        (0, _imageFilters.declareBlurMaskFilter)(ctx, props);
        break;
      }
    // Color Filters
    case _types.NodeType.LerpColorFilter:
      {
        node.children.forEach(child => processDeclarations(ctx, child));
        (0, _colorFilters.declareLerpColorFilter)(ctx, props);
        break;
      }
    case _types.NodeType.Blend:
      {
        node.children.forEach(child => processDeclarations(ctx, child));
        const {
          Skia
        } = ctx;
        const blend = _types2.BlendMode[(0, _nodes.enumKey)(props.mode)];
        // Blend ImageFilters
        const imageFilters = ctx.imageFilters.popAll();
        if (imageFilters.length > 0) {
          const composer = Skia.ImageFilter.MakeBlend.bind(Skia.ImageFilter, blend);
          ctx.imageFilters.push((0, _types.composeDeclarations)(imageFilters, composer));
        }
        // Blend Shaders
        const shaders = ctx.shaders.popAll();
        if (shaders.length > 0) {
          const composer = Skia.Shader.MakeBlend.bind(Skia.Shader, blend);
          ctx.shaders.push((0, _types.composeDeclarations)(shaders, composer));
        }
        break;
      }
    case _types.NodeType.BlendColorFilter:
      {
        const cf = (0, _colorFilters.makeBlendColorFilter)(ctx, props);
        composeColorFilters(ctx, cf, processChildren);
        break;
      }
    case _types.NodeType.SRGBToLinearGammaColorFilter:
      {
        const cf = (0, _colorFilters.makeSRGBToLinearGammaColorFilter)(ctx);
        composeColorFilters(ctx, cf, processChildren);
        break;
      }
    case _types.NodeType.LinearToSRGBGammaColorFilter:
      {
        const cf = (0, _colorFilters.makeLinearToSRGBGammaColorFilter)(ctx);
        composeColorFilters(ctx, cf, processChildren);
        break;
      }
    case _types.NodeType.MatrixColorFilter:
      {
        const cf = (0, _colorFilters.makeMatrixColorFilter)(ctx, props);
        composeColorFilters(ctx, cf, processChildren);
        break;
      }
    case _types.NodeType.LumaColorFilter:
      {
        const cf = (0, _colorFilters.makeLumaColorFilter)(ctx);
        composeColorFilters(ctx, cf, processChildren);
        break;
      }
    // Shaders
    case _types.NodeType.Shader:
      {
        node.children.forEach(child => processDeclarations(ctx, child));
        (0, _shaders.declareShader)(ctx, props);
        break;
      }
    case _types.NodeType.ImageShader:
      {
        (0, _shaders.declareImageShader)(ctx, props);
        break;
      }
    case _types.NodeType.ColorShader:
      {
        (0, _shaders.declareColorShader)(ctx, props);
        break;
      }
    case _types.NodeType.Turbulence:
      {
        (0, _shaders.declareTurbulenceShader)(ctx, props);
        break;
      }
    case _types.NodeType.FractalNoise:
      {
        (0, _shaders.declareFractalNoiseShader)(ctx, props);
        break;
      }
    case _types.NodeType.LinearGradient:
      {
        (0, _shaders.declareLinearGradientShader)(ctx, props);
        break;
      }
    case _types.NodeType.RadialGradient:
      {
        (0, _shaders.declareRadialGradientShader)(ctx, props);
        break;
      }
    case _types.NodeType.SweepGradient:
      {
        (0, _shaders.declareSweepGradientShader)(ctx, props);
        break;
      }
    case _types.NodeType.TwoPointConicalGradient:
      {
        (0, _shaders.declareTwoPointConicalGradientShader)(ctx, props);
        break;
      }
    // Image Filters
    case _types.NodeType.BlurImageFilter:
      {
        const imgf = (0, _imageFilters.makeBlurImageFilter)(ctx, props);
        composeImageFilters(ctx, imgf, processChildren);
        break;
      }
    case _types.NodeType.OffsetImageFilter:
      {
        const imgf = (0, _imageFilters.makeOffsetImageFilter)(ctx, props);
        composeImageFilters(ctx, imgf, processChildren);
        break;
      }
    case _types.NodeType.DisplacementMapImageFilter:
      {
        node.children.forEach(child => processDeclarations(ctx, child));
        (0, _imageFilters.declareDisplacementMapImageFilter)(ctx, props);
        break;
      }
    case _types.NodeType.DropShadowImageFilter:
      {
        const imgf = (0, _imageFilters.makeDropShadowImageFilter)(ctx, props);
        composeImageFilters(ctx, imgf, processChildren);
        break;
      }
    case _types.NodeType.MorphologyImageFilter:
      {
        const imgf = (0, _imageFilters.makeMorphologyImageFilter)(ctx, props);
        composeImageFilters(ctx, imgf, processChildren);
        break;
      }
    case _types.NodeType.BlendImageFilter:
      {
        node.children.forEach(child => processDeclarations(ctx, child));
        (0, _imageFilters.declareBlendImageFilter)(ctx, props);
        break;
      }
    case _types.NodeType.RuntimeShaderImageFilter:
      {
        const imgf = (0, _imageFilters.makeRuntimeShaderImageFilter)(ctx, props);
        composeImageFilters(ctx, imgf, processChildren);
        break;
      }
    // Path Effects
    case _types.NodeType.SumPathEffect:
      {
        node.children.forEach(child => processDeclarations(ctx, child));
        (0, _pathEffects.declareSumPathEffect)(ctx);
        break;
      }
    case _types.NodeType.CornerPathEffect:
      {
        const pf = (0, _pathEffects.makeCornerPathEffect)(ctx, props);
        composePathEffects(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.Path1DPathEffect:
      {
        const pf = (0, _pathEffects.makePath1DPathEffect)(ctx, props);
        composePathEffects(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.Path2DPathEffect:
      {
        const pf = (0, _pathEffects.makePath2DPathEffect)(ctx, props);
        composePathEffects(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.Line2DPathEffect:
      {
        const pf = (0, _pathEffects.makeLine2DPathEffect)(ctx, props);
        composePathEffects(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.DashPathEffect:
      {
        const pf = (0, _pathEffects.makeDashPathEffect)(ctx, props);
        composePathEffects(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.DiscretePathEffect:
      {
        const pf = (0, _pathEffects.makeDiscretePathEffect)(ctx, props);
        composePathEffects(ctx, pf, processChildren);
        break;
      }
    // Paint
    case _types.NodeType.Paint:
      node.children.forEach(child => processDeclarations(ctx, child));
      (0, _paint.declarePaint)(ctx, props);
      break;
    default:
      console.log("Unknown declaration node: ", type);
  }
}
const preProcessContext = (ctx, props, node) => {
  const shouldRestoreMatrix = ctx.processMatrixAndClipping(props, props.layer);
  ctx.declCtx.save();
  node.children.forEach(child => {
    if (child.isDeclaration) {
      processDeclarations(ctx.declCtx, child);
    }
  });
  const shouldRestorePaint = ctx.processPaint(props);
  ctx.declCtx.restore();
  return {
    shouldRestoreMatrix,
    shouldRestorePaint
  };
};
const postProcessContext = (ctx, {
  shouldRestoreMatrix,
  shouldRestorePaint
}) => {
  if (shouldRestoreMatrix) {
    ctx.canvas.restore();
  }
  if (shouldRestorePaint) {
    ctx.restore();
  }
};
const drawBackdropFilter = (ctx, node) => {
  const {
    canvas,
    Skia
  } = ctx;
  const child = node.children[0];
  let imageFilter = null;
  if (child.isDeclaration) {
    ctx.declCtx.save();
    processDeclarations(ctx.declCtx, child);
    const imgf = ctx.declCtx.imageFilters.pop();
    if (imgf) {
      imageFilter = imgf;
    } else {
      const cf = ctx.declCtx.colorFilters.pop();
      if (cf) {
        imageFilter = Skia.ImageFilter.MakeColorFilter(cf, null);
      }
    }
    ctx.declCtx.restore();
  }
  canvas.saveLayer(undefined, null, imageFilter);
  canvas.restore();
};
function draw(ctx, node) {
  // Special mixed nodes
  if (node.type === _types.NodeType.BackdropFilter) {
    drawBackdropFilter(ctx, node);
    return;
  }
  if (node.type === _types.NodeType.Layer) {
    let hasLayer = false;
    const [layer, ...children] = node.children;
    if (layer.isDeclaration) {
      const {
        declCtx
      } = ctx;
      declCtx.save();
      processDeclarations(ctx.declCtx, layer);
      const paint = declCtx.paints.pop();
      declCtx.restore();
      if (paint) {
        hasLayer = true;
        ctx.canvas.saveLayer(paint);
      }
    }
    children.map(child => {
      if (!child.isDeclaration) {
        draw(ctx, child);
      }
    });
    if (hasLayer) {
      ctx.canvas.restore();
    }
    return;
  }
  const {
    type,
    props: rawProps,
    children
  } = node;
  // Regular nodes
  const props = (0, _utils.materialize)(rawProps);
  const result = preProcessContext(ctx, props, node);
  const paints = ctx.getLocalPaints();
  paints.forEach(paint => {
    const lctx = {
      paint,
      Skia: ctx.Skia,
      canvas: ctx.canvas
    };
    switch (type) {
      case _types.NodeType.Box:
        (0, _drawings.drawBox)(lctx, props, node.children);
        break;
      case _types.NodeType.BoxShadow:
        (0, _drawings.drawBoxShadow)(lctx, props);
        break;
      case _types.NodeType.Image:
        (0, _drawings.drawImage)(lctx, props);
        break;
      case _types.NodeType.Points:
        (0, _drawings.drawPoints)(lctx, props);
        break;
      case _types.NodeType.Path:
        (0, _drawings.drawPath)(lctx, props);
        break;
      case _types.NodeType.Rect:
        (0, _drawings.drawRect)(lctx, props);
        break;
      case _types.NodeType.RRect:
        (0, _drawings.drawRRect)(lctx, props);
        break;
      case _types.NodeType.Oval:
        (0, _drawings.drawOval)(lctx, props);
        break;
      case _types.NodeType.Line:
        (0, _drawings.drawLine)(lctx, props);
        break;
      case _types.NodeType.Patch:
        (0, _drawings.drawPatch)(lctx, props);
        break;
      case _types.NodeType.Vertices:
        (0, _drawings.drawVertices)(lctx, props);
        break;
      case _types.NodeType.DiffRect:
        (0, _drawings.drawDiffRect)(lctx, props);
        break;
      case _types.NodeType.Text:
        (0, _drawings.drawText)(lctx, props);
        break;
      case _types.NodeType.TextPath:
        (0, _drawings.drawTextPath)(lctx, props);
        break;
      case _types.NodeType.TextBlob:
        (0, _drawings.drawTextBlob)(lctx, props);
        break;
      case _types.NodeType.Glyphs:
        (0, _drawings.drawGlyphs)(lctx, props);
        break;
      case _types.NodeType.Picture:
        (0, _drawings.drawPicture)(lctx, props);
        break;
      case _types.NodeType.ImageSVG:
        (0, _drawings.drawImageSVG)(lctx, props);
        break;
      case _types.NodeType.Paragraph:
        (0, _drawings.drawParagraph)(lctx, props);
        break;
      case _types.NodeType.Atlas:
        (0, _drawings.drawAtlas)(lctx, props);
        break;
      case _types.NodeType.Circle:
        (0, _drawings.drawCircle)(lctx, props);
        break;
      case _types.NodeType.Fill:
        (0, _drawings.drawFill)(lctx, props);
        break;
      case _types.NodeType.Group:
        // TODO: do nothing
        break;
      default:
        if (!node.isDeclaration) {
          console.warn(`Unsupported node type: ${type}`);
        }
    }
  });
  children.forEach(child => {
    if (!child.isDeclaration) {
      draw(ctx, child);
    }
  });
  postProcessContext(ctx, result);
}
//# sourceMappingURL=context.js.map