"worklet";

function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import { enumKey, isPathDef, processPath, processTransformProps2 } from "../dom/nodes";
import { DeclarationContext } from "../dom/types";
import { BlendMode, ClipOp, isRRect, PaintStyle, StrokeCap, StrokeJoin } from "../skia/types";
const computeClip = (Skia, clip) => {
  if (clip) {
    if (isPathDef(clip)) {
      return {
        clipPath: processPath(Skia, clip)
      };
    } else if (isRRect(clip)) {
      return {
        clipRRect: clip
      };
    } else {
      return {
        clipRect: clip
      };
    }
  }
  return undefined;
};
export class DrawingContext {
  constructor(Skia, canvas) {
    _defineProperty(this, "paints", void 0);
    _defineProperty(this, "declCtx", void 0);
    _defineProperty(this, "Skia", void 0);
    _defineProperty(this, "canvas", void 0);
    this.Skia = Skia;
    this.canvas = canvas;
    this.paints = [Skia.Paint()];
    this.declCtx = new DeclarationContext(this.Skia);
  }
  save() {
    this.paints.push(this.paint.copy());
  }
  restore() {
    this.paints.pop();
  }
  get paint() {
    const paint = this.paints[this.paints.length - 1];
    if (!paint) {
      throw new Error("Paint is undefined");
    }
    return paint;
  }
  getLocalPaints() {
    const {
      paint
    } = this;
    return [paint, ...this.declCtx.paints.popAll()];
  }
  processPaint({
    opacity,
    color,
    strokeWidth,
    blendMode,
    style,
    strokeJoin,
    strokeCap,
    strokeMiter,
    antiAlias,
    dither,
    paint: paintProp
  }) {
    if (paintProp) {
      this.declCtx.paints.push(paintProp);
      return true;
    }
    let shouldRestore = false;
    const colorFilter = this.declCtx.colorFilters.popAllAsOne();
    const imageFilter = this.declCtx.imageFilters.popAllAsOne();
    const shader = this.declCtx.shaders.pop();
    const maskFilter = this.declCtx.maskFilters.pop();
    const pathEffect = this.declCtx.pathEffects.popAllAsOne();
    if (opacity !== undefined || color !== undefined || strokeWidth !== undefined || blendMode !== undefined || style !== undefined || strokeJoin !== undefined || strokeCap !== undefined || strokeMiter !== undefined || antiAlias !== undefined || dither !== undefined || colorFilter !== undefined || imageFilter !== undefined || shader !== undefined || maskFilter !== undefined || pathEffect !== undefined) {
      if (!shouldRestore) {
        this.save();
        shouldRestore = true;
      }
    }
    const {
      paint
    } = this;
    if (opacity !== undefined) {
      paint.setAlphaf(paint.getAlphaf() * opacity);
    }
    if (color !== undefined) {
      const currentOpacity = paint.getAlphaf();
      paint.setShader(null);
      if (typeof color === "string" || typeof color === "number") {
        paint.setColor(this.Skia.Color(color));
      } else if (Array.isArray(color)) {
        paint.setColor(new Float32Array(color));
      } else if (color instanceof Float32Array) {
        paint.setColor(color);
      } else {
        throw new Error("Invalid color");
      }
      paint.setAlphaf(currentOpacity * paint.getAlphaf());
    }
    if (strokeWidth !== undefined) {
      paint.setStrokeWidth(strokeWidth);
    }
    if (blendMode !== undefined) {
      paint.setBlendMode(BlendMode[enumKey(blendMode)]);
    }
    if (style !== undefined) {
      paint.setStyle(PaintStyle[enumKey(style)]);
    }
    if (strokeJoin !== undefined) {
      paint.setStrokeJoin(StrokeJoin[enumKey(strokeJoin)]);
    }
    if (strokeCap !== undefined) {
      paint.setStrokeCap(StrokeCap[enumKey(strokeCap)]);
    }
    if (strokeMiter !== undefined) {
      paint.setStrokeMiter(strokeMiter);
    }
    if (antiAlias !== undefined) {
      paint.setAntiAlias(antiAlias);
    }
    if (dither !== undefined) {
      paint.setDither(dither);
    }
    if (colorFilter) {
      paint.setColorFilter(colorFilter);
    }
    if (imageFilter) {
      paint.setImageFilter(imageFilter);
    }
    if (shader) {
      paint.setShader(shader);
    }
    if (maskFilter) {
      paint.setMaskFilter(maskFilter);
    }
    if (pathEffect) {
      paint.setPathEffect(pathEffect);
    }
    return shouldRestore;
  }
  processMatrixAndClipping(props, layer) {
    const hasTransform = props.matrix !== undefined || props.transform !== undefined;
    const clip = computeClip(this.Skia, props.clip);
    const hasClip = clip !== undefined;
    const op = props.invertClip ? ClipOp.Difference : ClipOp.Intersect;
    const m3 = processTransformProps2(this.Skia, props);
    const shouldSave = hasTransform || hasClip || !!layer;
    if (shouldSave) {
      if (layer) {
        if (typeof layer === "boolean") {
          this.canvas.saveLayer();
        } else {
          this.canvas.saveLayer(layer);
        }
      } else {
        this.canvas.save();
      }
    }
    if (m3) {
      this.canvas.concat(m3);
    }
    if (clip) {
      if ("clipRect" in clip) {
        this.canvas.clipRect(clip.clipRect, op, true);
      } else if ("clipRRect" in clip) {
        this.canvas.clipRRect(clip.clipRRect, op, true);
      } else {
        this.canvas.clipPath(clip.clipPath, op, true);
      }
    }
    return shouldSave;
  }
}
//# sourceMappingURL=DrawingContext.js.map